import { describe, it, expect } from 'vitest';
import {
unique,
chunk,
flatten,
shuffle,
sample,
difference,
intersection,
groupBy,
} from './array';

describe('Array Utils', () => {
describe('unique', () => {
it('removes duplicates', () => {
expect(unique([1, 2, 2, 3, 3, 3])).toEqual([1, 2, 3]);
});

it('handles empty array', () => {
expect(unique([])).toEqual([]);
});
});

describe('chunk', () => {
it('chunks array into smaller arrays', () => {
expect(chunk([1, 2, 3, 4, 5], 2)).toEqual([[1, 2], [3, 4], [5]]);
});

it('handles exact division', () => {
expect(chunk([1, 2, 3, 4], 2)).toEqual([[1, 2], [3, 4]]);
});

it('throws on invalid size', () => {
expect(() => chunk([1, 2, 3], 0)).toThrow();
});
});

describe('flatten', () => {
it('flattens nested arrays', () => {
expect(flatten([[1, 2], [3, [4, 5]]])).toEqual([1, 2, 3, 4, 5]);
});

it('respects depth', () => {
expect(flatten([[1, [2, [3]]]], 1)).toEqual([1, [2, [3]]]);
});
});

describe('shuffle', () => {
it('returns array of same length', () => {
const arr = [1, 2, 3, 4, 5];
expect(shuffle(arr)).toHaveLength(arr.length);
});

it('does not modify original array', () => {
const arr = [1, 2, 3, 4, 5];
const original = [...arr];
shuffle(arr);
expect(arr).toEqual(original);
});
});

describe('sample', () => {
it('returns an element from the array', () => {
const arr = [1, 2, 3, 4, 5];
expect(arr).toContain(sample(arr));
});

it('returns undefined for empty array', () => {
expect(sample([])).toBeUndefined();
});
});

describe('difference', () => {
it('returns elements in first array but not second', () => {
expect(difference([1, 2, 3], [2, 3, 4])).toEqual([1]);
});
});

describe('intersection', () => {
it('returns elements in both arrays', () => {
expect(intersection([1, 2, 3], [2, 3, 4])).toEqual([2, 3]);
});
});

describe('groupBy', () => {
it('groups elements by key', () => {
const arr = [{ a: 1 }, { a: 2 }, { a: 1 }];
const result = groupBy(arr, (x) => x.a);
expect(result).toEqual({
1: [{ a: 1 }, { a: 1 }],
2: [{ a: 2 }],
});
});
});
});